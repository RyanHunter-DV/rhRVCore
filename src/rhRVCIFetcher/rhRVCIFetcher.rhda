rhload 'basicFeatures.rhda' ## rhload should support loading .rhda

interface 'chagePCReq' do ##{{{
end ##}}}

component 'RhRVCIFetcher_arbitor' do |*opts| ##{{{
	descp <<-DOC
		The block will arbitrate the incoming request of change PC
		the interrupt has the highest priority, the executor is next, and
		internal is last.
		The arbitor has no any buffer to cache the incoming request, so any
		granted valid will be passed to reqIssuer immediately without a handshake.
	DOC


	type :block

	vld = port('vld_w',1)
	pc  = port('pc_w',32)

	g0 = group('intrPCR',vld,pc);
	g1 = group('execPCR',vld,pc);
	g2 = group('internalPCR',vld,pc,'ack_w');
	gout = group('grantedPCR',vld,pc);
	q0 = group('intrPCR',vld,pc)

	cr = group('','clk_i','rstn_i');
	d0 = group('intrPCR',port('vld_i',1),port('pc_i',32))
	c0 = 'grantedPCR_ack_w'

	f_bufferHasClear(cr,d0,c0,q0);
	f_bufferHasClear(cr,d1,c0,q1);
	f_hightolowArbitor(3,g0,g1,g2,gout);

end ##}}}

component 'RhRVCIFetcher_internalPCR' do |*opts| ##{{{
	type :block
	## TODO
end ##}}}
component 'RhRVCIFetcher_reqIssuer' do |*opts| ##{{{
	type :block
	descp <<-DOC
		This is a block of request issuer to ICache, the issuer will
		give ICache a reqVld, reqPC, and the ICache will give a reqReady
		signal, once the reqReady is low, then the issuer should wait
		for the reqReady high again before issueing next request.
		For incoming pc change request from arbitor, this block should be
		able to cache the request, wait until the last req is acknowledged.
	DOC
end ##}}}

component 'RhRVCIFetcher' do |*opts| ##{{{
	type :vmod

	execPCR = i_changePCReq.receive
	intrPCR = i_changePCReq.receive
	ipcv= 'internalPCR_vld_w'
	ipc = 'internalPCR_PC_w'
	gpc = 'grantedPC_w'
	gvld= 'grantedVld_w'

	c_RhRVCIFetcher_arbitor

	c_RhRVCIFetcher_internalPCR(
		gpc,
		ipcv,ipc
	)

	c_RhRVCIFetcher_reqIssuer(
	)

end ##}}}
